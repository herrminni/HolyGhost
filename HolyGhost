#!/usr/bin/perl -w

# FEATURES TODO
# make har and screenshots configurable
# cli switch for casperjs binary

# Usage:
sub PrintUsage {
print <<USAGE;
Copyright (c) 2013 Michael Kraus

TODO GNU Public License

TODO Requirements Perl LibXML

Usage: $0 Opions:
	--test		file containing testcase (REQUIRED)
	--dir		destination directory of test results (REQUIRED)
	--proxy		specify the proxy server to use, e.g. --proxy=192.168.1.42:8080
	--keep		keep test results (screenshots and HAR files) on success
	--debug		enable debugging output
USAGE
exit 0;
}

use strict;
use Getopt::Long;
use POSIX qw(strftime);
use File::Path qw(make_path remove_tree);
use XML::LibXML;
use File::Spec;
use File::Basename;
my $scriptpath = dirname(File::Spec->rel2abs( __FILE__ ));

# Casper executable to use
my $casper_bin = '/usr/bin/casperjs';
 
# Extended die
sub die_rc { my $return_code = shift; die @_ }

# Set base variables
my $pid = $$;
my $timestamp = ( strftime "%Y-%m-%d_%H-%M-%S", localtime );

#Prepare exit states
my %ERRORS = (
	'UNKNOWN',  '3',
	'OK',       '0',
	'WARNING',  '1',
	'CRITICAL', '2'
);

# Parse options
my %opt;
my @required_opts = qw(test dir);
GetOptions(
	"h|help" => \&PrintUsage,
	"test=s" => \$opt{test},
	"dir=s" => \$opt{dir},
	"proxy:s" => \$opt{proxy},
	"keep" => \$opt{keep},
	"debug" => \$opt{debug},
 );
foreach(@required_opts)
{
	if ( not defined $opt{$_} )
	{
		die_rc(3, "UNKNOWN: Required parameter --$_ not defined! See $0 -h for help.\n");
	}
}

# Create test result directory
my $dest_dir = $opt{dir} . '/' . $timestamp . '_' . $pid;
if ( ! -e $dest_dir )
{
	make_path($dest_dir) or die_rc(3, "UNKNOWN: Could not create directory $dest_dir - $!");
}


my $casper_cmd = $casper_bin.' --fail-fast --no-colors --ignore-ssl-errors=true --pre='.$scriptpath.'/HolyGhost.js --hgResultpath='.$dest_dir.' --hgHar --hgScreenshot';
if ($opt{proxy})
{
	$casper_cmd .= ' --proxy-type=http --proxy='.$opt{proxy};
} else {
	$casper_cmd .= ' --proxy-type=none';
}
if ($opt{debug})
{
	$casper_cmd .= ' --direct --debug=true';
}
$casper_cmd .= ' --xunit=\''.$dest_dir.'/xunit.log\' test '.$opt{test};
#DEBUG
#print $casper_cmd."\n";

my @output = `$casper_cmd`;
my $rc = ($? >> 8);
my @detailed = grep (/^PASS|^FAIL|^#\s{2,}/,@output);
# TODO safe escape detailed output, especially "|"
# TODO handle CasperError

# Parse xunit log
my %steps;
my $parser = XML::LibXML->new();
my $root = $parser->parse_file($dest_dir.'/xunit.log') or die_rc(3, "UNKNOWN: Cannot open " . $dest_dir . "/xunit.log for parsing\n");

# Note:
# A HolyGhost-"Case" consist of exactly one xunit-"Testsuite", only the first Testsuite will be parsed.
# A Holyghost-"Step" consists of one or more following xunit-"Testcases".
my @cases = $root->findnodes('/testsuites/testsuite');
my $case = shift(@cases);

my $case_name = $case->getAttribute("name");
my ( $case_state, $case_shortname, $case_desc) = split(/::/, $case_name);
unless ( $case_state =~ /^OK$|^WARNING$|^ERROR$|^CRITICAL$|^UNKNOWN$/ ) {
	$case_state = "UNKNOWN";
}
my $case_time = $case->getAttribute("time");

my %step;
TESTCASE: foreach my $step ($root->findnodes('/testsuites/testsuite[@name="'.$case_name.'"]/testcase')) {
	my $step_name = $step->getAttribute("name");
	my ( $step_shortname, $step_desc) = split(/::/, $step_name);
	$step{$step_shortname} += $step->getAttribute("time");
}
# Remove xunit.log after parsing
unlink($dest_dir.'/xunit.log');

# Format perfdata
my $perfdata = "|";
foreach my $pstep ( keys %step ) {
	$perfdata .= "\'$pstep\'=".$step{$pstep}."s ";
}
$perfdata .= "\'TOTAL\'=". $case_time."s ";

# Format plugin output
my $output;
if ( $rc == 0 ) {
	$output = "OK: $case_shortname ( $case_desc ) passed.".$perfdata."\n";
} else {
	$output = "$case_state: $case_shortname ( $case_desc ) failed.".$perfdata."\n";
	$rc = $ERRORS{$case_state};
}
print $output;
print @detailed;	

# Remove results on test success if "keep" is not desired
unless ($opt{keep})
{
	if ( $rc == 0 )
	{
		remove_tree($dest_dir) or print $!;
	}
}

exit $rc;
